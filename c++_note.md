
## C++ Learn Note

- string对象不能直接 cout, 必须#include< string >才能cout，或转成char*型输出  char* b = (char *)a.c_str()
- 数组不能直接用=赋值 ， 用strcpy（a,b）
- string中 c_str()包含'\0' data()可不包含'\0'
- const char* 与 char* const 区别 ：https://www.cnblogs.com/belfuture/p/5862110.html  
                                    https://blog.csdn.net/swibyn/article/details/20052371
- 1.加了const的成员函数可以被非const对象和const对象调用，但不加const的成员函数只能被非const对象调用<br>
  2.const对象不可调用非const成员函数
- 为什么虚函数不能加static？<br>
   因为static函数不需要对象来调用，可通过类名直接调用，所有没有隐藏this指针（在编译时绑定），而虚函数(在链接时绑定)需要对象来调用，隐藏了this指针。所以不能虚函数不能加static。
- 没有虚函数的类不适合做基类。
- 并发是一种能力，时间片轮转和并行是实现并发的方法
- 编译多态性体现在重载和模板，运行多态性体现在虚函数
- 引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。
- 临时变量不能作为非const的引用参数。
- float/doublt 不能用==来比较 因为有精度要求 所以要用 (a-b) < 0.00001 | (a-b) > -0.000001 
- 全局变量的构造函数,全局变量的赋值函数在main函数前执行
- 关键段和互斥量会记录线程ID，即有“线程拥有权”，所以不能解决同步问题。事件，信号量可解决同步问题。

### 2019.3.8
- 曾经是这样的：16位操作系统中，int 占16位；在32位操作系统中，int 占32位。但是现在人们已经习惯了 int 占32位，因此在64位操作系统中，int 仍为32位。既仍然为4个字节。64位整型用 long long 或者 __int64
- 可寻址的最小内存块称为字节，存储的基本单元称为字，大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8比特。

### 2019.3.12
- 当赋给无符号类型一个超出它范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
- 当赋给带符号类型一个超出它范围的值时，结果是未定义。
- 无符号类型与int相加，会先把int转换为无符号类型，因此无符号与int相加时要注意int是否为负数 P34
- 如果内置类型的变量未被显示初始化，它的值将由定义的位置来决定，定义于任何函数之外的变量将被初始化为0,定义于函数体内的变量将不被初始化。类对象如果没有显示初始化，则其值由类确定。
- 如果想声明一个变量而不想定义它，那么可以在变量名前加extern关键字，而且不要显示的初始化变量。
- 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。
- 复合类型 基于其他类型定义的类型， c++ --> 指针和引用
- 一般在初始化变量时，初始值会被拷贝到新建的对象中，然后定义引用时，程序会把引用和初始值绑定在一起，而不是把初始值拷贝给引用，一旦初始化完成，引用将和它的初始值对象一直绑定在一起，因为无法令引用重新绑定到另一个对象，因此引用必须初始化。
- 引用类型必须一致
```
double a = 1.1; int &r = a;  x
int a = 1;  double &r = a;   x
```
- 引用的类型必须与其所引用对象的类型一致，const引用除外。
- 指针的类型必须与其所指的对象的类型一致，const指针除外。
```
所谓指向常量的指针或引用，不过是指针和引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值
```
- 引用r的赋值对象必须是一个对象
```
int &r = 0;          X
const int &r = 0;    对
```
- 顶层const:指的是本身不可以被改变。底层const:指的是自身所指对象不可以被改变。用于声明引用的const都是底层const.顶层const的拷贝不受限制，但是底层const的拷贝的对象必须具有相同的底层const资格。一般来说：非常量可以赋值给常量，反之则不行.
- constexpr 常量表达式，常量表达式的值必须在编译时就得到计算
- 切记把别名替换成它本来的样子会带来意想不到的错误。
```
typedef char* pstring;
const pstring cstr = 0; //这是一个常量指针，而不是一个指向字符常量的指针(可以这样理解，pstring是一个指向char指针，const修饰指针）
```
- auto定义的变量必须有初始值，在一条语句中声明多个变量时，必须保证该语句的所有变量的数据类型是一样的 

### 20190313
- string的size函数返回string::size_type类型，请注意该类型为无符号整形，vector的size函数返回vector<T>::size_type类型
- string比较
```
strcmp()函数有许多变体，它们的基本功能是相同的，都是比较两个字符串，但其它地方稍有差别。下表列出了C语言提供的与strcmp()函数类似的一些函数：   
-----------------------------------------------------------------
    函  数  名                   作  用
-----------------------------------------------------------------
    strcmp()         对两个字符串进行大小写敏感的比较
    strcmpi()        对两个字符串进行大小写不敏感的比较
    stricmp()        同strcmpi()
    strncmp()        对两个字符串的一部分进行大小写敏感的比较
    strnicmp()       对两个字符串的一部分进行大小写不敏感的比较
-----------------------------------------------------------------
在前面的例子中，如果用strcmpi()函数代替strcmp()函数，则程序将认为字符串“ABC”等于“abc”。
```
- 为了与c兼容，c++中的字符串字面值并不是string对象。字面值不能直接相加，必须保证每个加法运算的两侧的运算对象至少一个是string
```
string s = "a" + "b";  x
string s = s1 + "a";   对
```
- cin与getline
```
cin 不保存空百符，换行符
getline 保留空白符，不保存换行符号
```
- 早期c++标准中，如果vector的元素还是vector(或其他模板类)，则其定义的形式为vector<vector<int> >(多一个空格) 而非现在的vector<vector<int>>
- 引用不可以成为vector的元素，因为其不是对象
- vector 初始化
```
  vector<int> T(10,1)    -> 10个元素都为1
  vector<int> T{1,2}     -> 2个元素分别为1，2
  vector<string>(10,"a") -> 10个元素都为"a"
  vector<string>{10,"a"} -> 10个元素都为"a"   p89
```
- vector对象(以及string对象)的下标运算符可用于访问已经存在的元素，而不能用于添加元素
- 只有string和vector等一些标准库类型有下标运算符，而并非全部如此，与之类似，所有标准库容器的迭代器都定义了==和！=，但是它们中的大多数没有定义<运算符，因此要养成使用迭代器和！=的习惯
- begin，end 与cbegin，cend区别 p98
- difference_type类型，两个迭代器相减后返回的类型，表示两个迭代器的距离，可正可负
- 数组的元素应为对象，因此不存在引用的数组，定义数组时必须指定数组的类型，不允许使用auto来推断
- 可以用字符串字面值对字符数组进行初始化，但一定要注意字符串字面值的结尾处有一个空字符，这个空字符也会拷贝到字符数组中去
```
char s[4] = {abcd};  x
char s[5] = {abcd};  dui                                                                                                 
```                                                                                                 
- 数组的拷贝
```
1.字符数组 strcpy
2.int,float,double等数组 memcpy
3.对象数组 不能使用以上两种，需要实现拷贝构造函数或赋值重载函数。             
```       
- 数组并未提供返回长度的函数，可通过sizeof(a)/sizeof(a[0]) 或者 end(a)-begin(a)来获取数组长度      
- 复杂数组
```
int *ptrs[10]  ptr是含有10个整形指针的数组
int &refs[10]  x 不存在引用的数组
int (*ptrs)[10]  ptr是指向一个含有10个整形的数组的指针
int (&refs)[10]  refs引用一个含有10个整形的数组
int *(&refs)[10] refs引用一个含有10个整形指针的数组                                                                                         
```
- 数组下标 类型 size_t                                                                                       
