
## C++ Learn Note

- string对象不能直接 cout, 必须#include< string >才能cout，或转成char*型输出  char* b = (char *)a.c_str()
- 数组不能直接用=赋值 ， 用strcpy（a,b）
- string中 c_str()包含'\0' data()可不包含'\0'
- const char* 与 char* const 区别 ：https://www.cnblogs.com/belfuture/p/5862110.html  
                                    https://blog.csdn.net/swibyn/article/details/20052371
- 1.加了const的成员函数可以被非const对象和const对象调用，但不加const的成员函数只能被非const对象调用<br>
  2.const对象不可调用非const成员函数
- 为什么虚函数不能加static？<br>
   因为static函数不需要对象来调用，可通过类名直接调用，所有没有隐藏this指针（在编译时绑定），而虚函数(在链接时绑定)需要对象来调用，隐藏了this指针。所以不能虚函数不能加static。
- 没有虚函数的类不适合做基类。
- 并发是一种能力，时间片轮转和并行是实现并发的方法
- 编译多态性体现在重载和模板，运行多态性体现在虚函数
- 引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。
- 临时变量不能作为非const的引用参数。
- float/doublt 不能用==来比较 因为有精度要求 所以要用 (a-b) < 0.00001 | (a-b) > -0.000001 
- 全局变量的构造函数,全局变量的赋值函数在main函数前执行
- 关键段和互斥量会记录线程ID，即有“线程拥有权”，所以不能解决同步问题。事件，信号量可解决同步问题。

### 2019.3.8
- 曾经是这样的：16位操作系统中，int 占16位；在32位操作系统中，int 占32位。但是现在人们已经习惯了 int 占32位，因此在64位操作系统中，int 仍为32位。既仍然为4个字节。64位整型用 long long 或者 __int64
- 可寻址的最小内存块称为字节，存储的基本单元称为字，大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8比特。

### 2019.3.12
- 当赋给无符号类型一个超出它范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
- 当赋给带符号类型一个超出它范围的值时，结果是未定义。
- 无符号类型与int相加，会先把int转换为无符号类型，因此无符号与int相加时要注意int是否为负数 P34
- 如果内置类型的变量未被显示初始化，它的值将由定义的位置来决定，定义于任何函数之外的变量将被初始化为0,定义于函数体内的变量将不被初始化。类对象如果没有显示初始化，则其值由类确定。
- 如果想声明一个变量而不想定义它，那么可以在变量名前加extern关键字，而且不要显示的初始化变量。
- 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。
- 复合类型 基于其他类型定义的类型， c++ --> 指针和引用
- 一般在初始化变量时，初始值会被拷贝到新建的对象中，然后定义引用时，程序会把引用和初始值绑定在一起，而不是把初始值拷贝给引用，一旦初始化完成，引用将和它的初始值对象一直绑定在一起，因为无法令引用重新绑定到另一个对象，因此引用必须初始化。

